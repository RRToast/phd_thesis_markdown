# Grundlagen
Diese Bachelorarbeit baut auf dem TPM sowie dem ACME Protokoll auf. In diesem Abschnitt der Arbeit sollen diese beiden Themenbereiche so erklärt werden, dass in den Folgenden Kapiteln klar wird auf welchem Fundament die Arbeit aufgebaut ist. Denn Sie stellen die Grundlage für die Identifizierung der Endbenutzersysteme, sowie die sichere Erstellung, Verteilung und Verwaltung von X.509 Zertifikate dar. Zuerst werden grundlegende Funktionalitäten des TPM Moduls besprochen, bevor der Ablauf sowie die wichtigsten Konzepte des ACME Protokolls dargestellt werden.

## TPM
Das Trusted Platform Module ist ein Modul, mit dem Funktionen der Sicherheit auf einer physischen Ebene umgesetzt werden sollen. Obwohl dieses Modul erst 2009 von der International Organization for Standardization (ISO) und International Electrotechnical Commission (IEC) [@tpm_iso2009] beschrieben wurde, existierten 2011 bereits 300 Millionen dieser Chips [@a_formal_analysis_of_authentication_in_the_tpm], eine Zahl, die mit der Ankündigung von Windows, für ihr neues Betriebsystem Windows 11 TPM2.0 Chips als Anforderung zu stellen, wahrscheinlich weiter steigen wird[@heise_tpm_windows]. Die Idee des TPM Moduls ist es, die Limitationen und Probleme, die Sicherheitssoftware und standardmäßige Hardware mit sich bringen, zu beheben. Darunter fallen unsicherer Speicher, volatiler Speicher sowie unsichere kryptographische Hardware.
Der Aufbau des TPM ist etwas komplexer und wird in dem ofiziellen Dokument der Trusted Computing Group auf etwas über 300 Seiten zusammengefasst[@tpm-architektur]. Durch eine eigene API, welche das Modul zur Verfügung stellt, ist es möglich mit diesem zu kommunizieren. Gleichzeitig besitzt das Modul zwei, für diese Arbeit sehr relevante Komponenten. Einmal einen geschützten persistenen Speicher, welcher es erlaubt wichtige Informationen sicher abzuspeichern[@a_formal_analysis_of_authentication_in_the_tpm]. Zum anderen eine kryptographische Einheit welche Schlüsselpaare erstellen kann [@tpm-aufbau]. Dabei wird unter anderem sichergestellt, dass die kryptographischen Verfahren auf Hadware ausgeführt werden, die dafür gemacht ist, sichere Ergebnisse zu liefern. Für Schlüsselpaare, die mithilfe der kryptographischen Einheit erstellt werden, kann sichergestellt werden, dass der private Teil des Schlüssels nach der Erstellung auf dem TPM direkt in dem gesicherten persistenent Speicher abgelegt wird und das Modul zu keiner Zeit verlässt. Diese Tatsache kann verwendet werden um das Gerät, welches den TPM Chip verwendet, an diesem zu identifizieren. Jeder Chip verfügt über einen sogenannten Endorsement Key. Dabei handelt es sich um drei Teile: einen privaten Key im gesicherten Speicher auf den nicht zugegriffen werden kann, einen public Key auf den zugegriffen werden kann, sowie ein Zertifikat welches vom Hersteller signiert wurde[@a_practical_guide_to_tpm]. An diesem Zertifikat in Verbindung mit dem entsprechenden private Key kann der TPM Chip eindeutig identifiziert werden.

## ACME
ACME steht für Automatic Certificate Canagement Enviroment, also eine automatische Zertifikats-Verwaltungs-Umgebung. Diese besteht aus zwei Teilen: erstens einer Certificate Authority (CA) welche Zertifikate erstellt und verwaltet und zweitens einer automatisierten Schnittstelle welche erst prüft ob Anfragen valide sind und diese dann an die CA weiter gibt. Dadurch können Zertifikate automatisch angefragt werden. Dazu wird auf dem Gerät, welches ein Zertifikat benötigt, ein ACME Client ausgeführt, welcher eine Anfrage an den entsprechenden ACME Server stellt. Dieser prüft dann mit sogenannten Challenges, dass der Client tatsächlich ist der ist, für den er sich ausgibt. Ist der Client in der Lage die Challenge zu erfüllen kann dieser ein Zertifikat anfragen. Dieses Prinzip soll sich für diese Bachelorarbeit zunutze gemacht werden. Auch hier soll mit einem automatisierten Verfahren erst der Client geprüft und anschließend ein Zertifikat ausgestellt werden.
Der ACME Server kann dabei nur mit integrierter Datenbank verwendet werden, da jeder Client, der ein Zertifikat anfragen möchte, zuerst einen Account erstellen muss, welcher in der Datenbank gespeichert wird. Für diesen Account kann der Client dann Anfragen nach Zertifikaten schicken, muss dabei jedoch für jede Anfrage eine Challenge erfüllen. Die Art der Challenge, ob nun DNS oder HTTP, beide werden im Verlauf der Arbeit noch genauer behandelt, kann der Client dabei frei wählen. Die folgenden Erklärungen beziehen sich auf ACME wie es im RFC-8555 definiert ist [@rfc-8555].

### Hintergrund
Ein ACME Server, der nicht gleichzeitig als Webserver dient, muss laut RFC-8555 mindestens eine Schnittstelle zur Verfügung stellen, die unverschlüsselt erreicht werden kann. Diese dient als Directory und Übersicht über alle URLs die benötigt werden, damit der Client mit dem Server kommunizieren kann. Darunter finden sich unter anderem URLs um ein Zertifikat zu widerrufen, eine Replay-Nonce zu erhalten und einen Account zu erstellen. Jede Kommunikation, mit Ausnahme des GET-Requests zum Erhalten des Directorys sowie dem Erhalten der Replay-Nonce, ist verschlüsselt und muss mit einer Replay-Nonce abgesichert werden. Dabei übersendet der Server bei jeder Anfrage des Client auch eine Replay-Nonce im Header des Responses mit, sodass diese nicht jedes Mal neu angefragt werden muss. Jede Kommunikation, ausgenommen der genannten zwei, muss als POST oder POST-as-GET Request durchgeführt werden. POST-as-GET bedeutet, dass jede Anfrage, die normalerweise ein GET-Request wäre, nun als POST Request mit leerem, aber signiertem Body, geschickt wird. POST-as-GET Requests sind unabdingbar, da jede Kommunikation durch JWS gesichert muss und der Body des GET Requests keine definierte Form hat[@rfc-7231]. Die Schlüsselpaare, die für die Kommunikation mit JWS notwendig sind, müssen vorher clientseitig erstellt werden.

### Ablauf
Folgend soll der Ablauf einer ACME Kommunikation von der ersten Nachricht bis zum Erhalt des Zertifikates dargestellt werden. Der Ablauf des ACME Protokolls ändert sich abhängig davon ob der Client bereits über einen Account auf dem Server verfügt. Hier soll der grundsätzliche Ablauf beschrieben werden, in dem der Client noch keinen Account besitzt, also Client und Server noch keinerlei Kontakt miteinander hatten. Der Einfachheit halber wird die Kommunikation aus Sicht des Clients dargestellt und die internen Abläufe des ACME Servers, da sie von Server zu Server unterschiedlich sein können, außer Acht gelassen.
Zu allererst muss der Client eine Anfrage an das Directory stellen um zu erfahren, welche URL für welche Kommunikation benötigt wird. Sind die URLs bereits bekannt, kann dieser vorbereitende Schritt übersprungen werden.

#### Die erste Nonce
Die Nonce wird im weiteren Ablauf des Protokolls in jedem Response des Servers mitgeschickt, damit der Client nicht wieder eine neue Anfrage nur für die Replay Nonce senden muss. Dadurch entsteht eine Kette, die aus Anfrage des Clients mit erhaltener Nonce und Antwort des Servers mit neuer Nonce besteht. Wenn die Nonce jedoch abgelaufen ist, da die letzte Kommunikation länger zurückliegt, oder der Client noch gar keine Anfrage gestellt hat und somit noch keine Nonce erhalten hat, kann der Client eine neue Nonce anfragen. Dazu schickt der Client einen HEAD Request an den Server, an die über das Directory erhaltene URL. Da jede Kommunikation, die nun beschrieben wird, eine Replay-Nonce verwendet, wurde darauf verzichtet, dies immer wieder anzuführen.

![RFC-8555 Get Nonce beispiel \label{get_nonce}](source/figures/AblaufGetNonce.png){ width=90% }


#### Account erstellen
Jede Order wird fest an einen Account gebunden und so muss zu Beginn ein neuer Account erstellt werden. Dazu sendet der Client in seiner JWS Payload Mailadressen, die mit diesem Account verknüpft werden sollen, sowie eine Bestätigung, dass der Client mit den Nutzungsbedingungen einverstanden ist, an den Server. Optional könnte in diesem Schritt auch ein bereits vorhandenes Konto verknüpft werden. Da noch keine Key ID (KID) vorhanden ist wird hier im Header an dessen Stelle der JWK mit dem entsprechendem öffentlichen Schlüssel, der zum Signieren verwendet wurde, an den Server gesendet.
Der Server antwortet in der Payload mit dem Status des Accounts, sowie mit der Account URL, welche im folgenden Ablauf als KID fungiert.
![RFC8555 New Account Request \label{new_account}](source/figures/AblaufGetAccount.png)

![RFC8555 New Account Server Response \label{newaccount_response}](source/figures/AblaufGetAccountResponse.png)

<!-- TODO: nocheinmal anpassen, Bild vielleicht weglassen oder näher darauf eingehen? -->

#### Order platzieren
Mit den im letzten Schritt erhaltenen Informationen kann der Client nun eine Order erstellen. Dazu sendet er in der Payload ein Identifier Array mit allem was er validiert haben möchte. In diesem Array wird nicht nur definiert mit welchem Verfahren dem sogennanten "type" sondern auch gegen welchen Wert "value" die Validierung stattfinden soll. Der Client kann sich aussuchen wie er geprüft werden möchte, die prominentesten zwei Verfahren, die DNS sowie die HTTP Challenge, werden im nächsten Schritt näher erläutert. Für beide übersendet der Client im "Type" des Identifier den Wert "dns" mit, wie in der folgenden Abbildung zu sehen.
Zusätzlich kann der Client durch das Übersenden von "notBefore" und "notAfter" Werten bestimmen, für welchen Zeitraum das Zertifikat gültig sein soll, das ist jedoch optional.
In der Antwort schickt der Server den Status, wann die Gültigkeit der Anfrage ausläuft, sowie ein Array an Links zur Validierung der Order mit. Für jeden Identifier mit type und value wird genau ein Link erstellt, im sogenannten "Authorizations" Array. Zusätzlich antwortet der Server mit einer finalize URL, die im späteren Verlauf benötigt wird.
![RFC8555 New Order Request \label{neworder}](source/figures/AblaufNewOrder.png)

#### Challenge aktivieren
Für den Client gibt es mehrere Methoden, mit denen er beim Server validieren kann, dass er tatsächlich ist, wer er zu sein vorgibt. Im RFC-8555 Dokument werden dabei zwei näher erläutert, die auch hier ausführlicher besprochen werden sollen, nämlich die HTTP und die DNS Challenge. Weiterführend gibt es Erweiterungen für das Dokument, wie eine Challenge welche die Kontrolle über eine IP Adresse prüft [@rfc-8738], oder die Domain über TLS prüfen [@rfc-8737]. Um zu verstehen wie ACME funktioniert, reicht es aber aus, sich auf DNS und HTTP Challenge zu beschränken.

Der Client sendet nun einen POST-as-GET Request an den Server, an die URL, deren Challenge er als erstes bearbeiten möchte.
Der Server antwortet nun mit Informationen zu dieser Challenge, wie dem Status wann sie abläuft, den entsprechenden Identifier-Werten und einem Array mit Challenges. Diese Challenges haben den type "http-01" oder "dns-01". Beide haben eine eigene URL, sowie einen gemeinsamen Token. Der Token ist dabei ein zufälliger base64 Wert, der die Challenge eindeutig identifiziert.

DNS Challenge:
Der Client kann aus diesem Token, in Verbindung mit seinem eigenen Account Key, einen Authorisierungsschlüssel (Authorization Key) erstellen. Dieser Schlüssel wird anschließend mit dem SHA-256 Verfahren verschlüsselt (hashed). Dieser Wert wird nun base64 encoded und in einem TXT Resource Record im DNS gespeichert. Dieses Dokument wird dabei unter der im Identifier Value angegebenen Domain unter dem Prefix "_acme-challenge" abgespeichert. Für "www.example.org" wird der Wert also unter "_acme-challenge.www.example.org" abgespeichert [@rfc-8555]. Der Client sendet nun einen POST-as-GET Request zum Server, um diesen zu informieren, dass dieser die Information anfragen kann.

HTTP Challenge:
Die http-01 Challenge läuft sehr ähnlich ab. Hier wird genauso ein Autorisierungsschlüssel erstellt, nur wird dieser Schlüssel unter "[domain]/.well-known/acme-challenge/[token]" für einen GET Request zur Verfügung gestellt.

#### Challenge erfüllen
Nun sendet der Client eine POST-as-GET Request an den Server, um ihn wissen zu lassen, dass er nun mit der Validierung beginnen kann. Um zu validieren, dass die Challenge erfüllt wurde, erstellt der Server den selben Hash, fragt von der Domain das TXT Resource Record oder die HTTP Ressource an und überprüft, dass der erhaltene Wert mit dem eigenen Wert übereinstimmt. Ist das gelungen, gilt die Challenge als bestanden.
<!--TODO: soll ich hier Vor und Nachteile ausführen?
Der große Vorteil dieser Challenge ist, das sogenannte WildCard Zertifikate ausgestellt werden können. Das heißt, dass der Client nicht für jede Subdomain eine eigene Anfrage mit Challenge stellen muss sondern alles für eine Domain validiert werden kann. Der Nachteil besteht allerdings darin, dass die DNS Challenge im Vergleich zur HTTP Challenge deutlich komplizierter aufzusetzen ist. (TODO: Vor und Nachteile ausführen, vielleicht mit Pros und Cons von hier: https://letsencrypt.org/docs/challenge-types/ ) -->

<!-- TODO: Hier entweder mehr schreiben oder zusammenfassen, gilt für jeden Punkt -->
#### Zertifikatsmanagement
Ist der Status für diese Order als Valide gesetzt, wurden also alle Challenges erfüllt, so kann der Client sein Zertifikat anfragen. Dazu sendet er dem Server eine Certificate Signing Request (CSR) an die finalize URL. Anhand dieser CSR erstellt nun der Server das Zertifikat und übersendet dem Client in der Antwort unter anderem die certificate URL, also den Ort, an dem das Zertifikat zur Verfügung steht, mit.

Um das Zertifikat anzufordern muss der Client jetzt nur noch einen POST-as-GET Request an die im letzten Schritt mitgeteilte URL senden. Der Server antwortet mit dem Zertifikat im Body der Antwort.

#### Weitere mögliche Schritte
Damit ist die Kommunikation abgeschlossen. Der Client kann nun über den erstellten Account die Zertifikate aktualisieren lassen, ohne die Challenges noch einmal durchlaufen zu müssen. Der Client kann den Server bitten, den Account zu löschen oder ein Zertifikat zu widerrufen. Auch ein sogenannter Key Change ist möglich, wenn der öffentliche und der private Schlüssel, welche für den Account und damit auch für die Kommunikation mit JWS verwendet wurden, geändert werden sollen. Dabei muss der Client den neuen Schlüssel in einer Nachricht verpacken, welche von dem alten Schlüssel signiert wurde.
